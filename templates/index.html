<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web-Burp - Intercepting Proxy</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/style.css') }}">
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
</head>
<body>
    <div class="container">
        <nav class="tabs">
            <button class="tab active" data-tab="dashboard">Dashboard</button>
            <button class="tab" data-tab="proxy">Proxy</button>
            <button class="tab" data-tab="history">History</button>
            <button class="tab" data-tab="intercept">Intercept</button>
            <button class="tab" data-tab="repeater">Repeater</button>
        </nav>

        <main>
            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-content active">
                <div class="card">
                    <h2>Welcome to Web-Burp</h2>
                    <p>Your browser-based intercepting proxy for pentesting and security research.</p>
                    
                    <div class="status-grid">
                        <div class="status-card">
                            <h3>Proxy Status</h3>
                            <p class="status-indicator offline" id="proxy-status">Offline</p>
                            <small>Port 8081</small>
                        </div>
                        <div class="status-card">
                            <h3>Requests Captured</h3>
                            <p class="stat-number" id="request-count">0</p>
                            <small>This session</small>
                        </div>
                        <div class="status-card">
                            <h3>Intercept</h3>
                            <p class="status-indicator offline">Off</p>
                            <small>Coming soon</small>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h3>Quick Start</h3>
                    <ol class="quick-start-list">
                        <li>Configure your browser to use <code>localhost:8081</code> as HTTP proxy</li>
                        <li>Install the CA certificate for HTTPS interception (coming soon)</li>
                        <li>Navigate to the Proxy tab to start capturing traffic</li>
                        <li>Use Intercept mode to modify requests/responses on-the-fly</li>
                    </ol>
                </div>
            </div>

            <!-- Proxy Tab -->
            <div id="proxy" class="tab-content">
                <div class="card">
                    <h2>Proxy Configuration</h2>
                    <p>Control the HTTP/HTTPS intercepting proxy server.</p>
                    
                    <div class="proxy-controls">
                        <div class="control-group">
                            <button id="start-proxy-btn" class="btn btn-success">Start Proxy</button>
                            <button id="stop-proxy-btn" class="btn btn-danger" disabled>Stop Proxy</button>
                        </div>
                        
                        <div class="proxy-info">
                            <h3>Proxy Settings</h3>
                            <div class="info-row">
                                <span class="label">Listen Address:</span>
                                <code>0.0.0.0:8081</code>
                            </div>
                            <div class="info-row">
                                <span class="label">Status:</span>
                                <span id="proxy-status-text" class="status-text offline">Offline</span>
                            </div>
                        </div>
                        
                        <div class="proxy-certificate">
                            <h3>üîí HTTPS Certificate Setup</h3>
                            <p>To intercept HTTPS traffic, install the mitmproxy CA certificate in your browser:</p>
                            
                            <div class="cert-status" id="cert-status">
                                <p>Loading certificate status...</p>
                            </div>
                            
                            <div id="cert-download" style="display: none;">
                                <button id="download-cert-btn" class="btn btn-success">Download CA Certificate</button>
                                
                                <details class="install-instructions">
                                    <summary>Installation Instructions</summary>
                                    
                                    <div class="browser-instructions">
                                        <h4>Chrome / Chromium / Edge</h4>
                                        <ol>
                                            <li>Download the certificate above</li>
                                            <li>Settings ‚Üí Privacy and security ‚Üí Security ‚Üí Manage certificates</li>
                                            <li>Go to "Authorities" tab</li>
                                            <li>Click "Import" and select the downloaded .pem file</li>
                                            <li>Check "Trust this certificate for identifying websites"</li>
                                            <li>Click OK</li>
                                        </ol>
                                        
                                        <h4>Firefox</h4>
                                        <ol>
                                            <li>Download the certificate above</li>
                                            <li>Settings ‚Üí Privacy & Security ‚Üí Certificates ‚Üí View Certificates</li>
                                            <li>Go to "Authorities" tab</li>
                                            <li>Click "Import" and select the downloaded .pem file</li>
                                            <li>Check "Trust this CA to identify websites"</li>
                                            <li>Click OK</li>
                                        </ol>
                                        
                                        <h4>Safari (macOS)</h4>
                                        <ol>
                                            <li>Download the certificate above</li>
                                            <li>Double-click the .pem file to open Keychain Access</li>
                                            <li>Find "mitmproxy" in the list and double-click it</li>
                                            <li>Expand "Trust" section</li>
                                            <li>Set "When using this certificate" to "Always Trust"</li>
                                            <li>Close the window and enter your password</li>
                                        </ol>
                                        
                                        <h4>curl (Command Line)</h4>
                                        <pre><code>curl --cacert ./mitmproxy-ca-cert.pem -x localhost:8081 https://httpbin.org/get</code></pre>
                                    </div>
                                </details>
                            </div>
                            
                            <div class="info-note">
                                <strong>‚ö†Ô∏è Security Note:</strong> The CA certificate allows full HTTPS interception. 
                                Only install it in browsers used for testing. Remove it when done.
                            </div>
                        </div>
                        
                        <div class="proxy-instructions">
                            <h3>Browser Configuration</h3>
                            <ol>
                                <li>Install the CA certificate above (required for HTTPS)</li>
                                <li>Open your browser's network settings</li>
                                <li>Configure HTTP proxy: <code>localhost:8081</code></li>
                                <li>Configure HTTPS proxy: <code>localhost:8081</code></li>
                                <li>Start browsing - traffic will be captured automatically</li>
                            </ol>
                            
                            <div class="info-note">
                                <strong>üí° Tip:</strong> Requests to <code>localhost</code> are automatically excluded 
                                to prevent capturing the web-burp interface's own traffic.
                            </div>
                        </div>
                        
                        <div class="proxy-exclusions">
                            <h3>Excluded Hosts</h3>
                            <p class="exclusion-desc">These domains won't be captured by the proxy:</p>
                            <ul id="exclusion-list" class="exclusion-list">
                                <li>Loading...</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <!-- History Tab -->
            <div id="history" class="tab-content">
                <div class="card">
                    <div class="history-header">
                        <h2>Request History</h2>
                        <button id="clear-history-btn" class="btn btn-small">Clear History</button>
                    </div>
                    
                    <div id="request-list" class="request-list">
                        <p class="empty-state">No requests captured yet. Start the proxy and configure your browser.</p>
                    </div>
                </div>
            </div>

            <!-- Intercept Tab -->
            <div id="intercept" class="tab-content">
                <div class="card">
                    <div class="intercept-header">
                        <div>
                            <h2>Intercept Requests</h2>
                            <p>Capture and modify requests before they are sent.</p>
                        </div>
                        <div class="intercept-controls">
                            <button id="intercept-toggle-btn" class="btn btn-success">Enable Intercept</button>
                            <span class="intercept-status offline" id="intercept-status-indicator">Off</span>
                        </div>
                    </div>
                    
                    <div id="intercept-content" class="intercept-content">
                        <div class="intercept-empty" id="intercept-empty">
                            <p>No intercepted requests. Enable intercept and configure your browser proxy to start capturing.</p>
                        </div>
                        
                        <div class="intercept-editor" id="intercept-editor" style="display: none;">
                            <div class="editor-header">
                                <h3>Intercepted Request <span id="current-request-id"></span></h3>
                                <div class="editor-actions">
                                    <button id="forward-btn" class="btn btn-success">Forward</button>
                                    <button id="forward-modified-btn" class="btn btn-warning">Forward (Modified)</button>
                                    <button id="drop-btn" class="btn btn-danger">Drop</button>
                                </div>
                            </div>
                            
                            <div class="editor-tabs">
                                <button class="editor-tab active" data-editor-tab="request">Request</button>
                                <button class="editor-tab" data-editor-tab="headers">Headers</button>
                                <button class="editor-tab" data-editor-tab="body">Body</button>
                            </div>
                            
                            <div class="editor-content">
                                <!-- Request Tab -->
                                <div id="editor-request" class="editor-tab-content active">
                                    <div class="form-group">
                                        <label>Method</label>
                                        <input type="text" id="edit-method" class="form-input" placeholder="GET">
                                    </div>
                                    <div class="form-group">
                                        <label>URL</label>
                                        <input type="text" id="edit-url" class="form-input" placeholder="https://example.com/path" readonly>
                                    </div>
                                    <div class="form-group">
                                        <label>Path</label>
                                        <input type="text" id="edit-path" class="form-input" placeholder="/path">
                                    </div>
                                    <div class="form-group">
                                        <label>Host</label>
                                        <input type="text" id="edit-host" class="form-input" readonly>
                                    </div>
                                </div>
                                
                                <!-- Headers Tab -->
                                <div id="editor-headers" class="editor-tab-content">
                                    <div class="headers-editor">
                                        <textarea id="edit-headers" class="form-textarea" rows="15" placeholder="Header-Name: value"></textarea>
                                        <small class="form-hint">One header per line in format: Header-Name: value</small>
                                    </div>
                                </div>
                                
                                <!-- Body Tab -->
                                <div id="editor-body" class="editor-tab-content">
                                    <div class="body-editor">
                                        <textarea id="edit-body" class="form-textarea" rows="15" placeholder="Request body content"></textarea>
                                        <small class="form-hint">Raw request body content</small>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="intercept-queue-info">
                                <span>Requests in queue: <strong id="queue-count">0</strong></span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Repeater Tab -->
            <div id="repeater" class="tab-content">
                <div class="card">
                    <h2>Request Repeater</h2>
                    <p>Manually craft and send HTTP requests.</p>
                    
                    <div class="repeater-container">
                        <div class="repeater-main">
                            <!-- Request Editor -->
                            <div class="repeater-section">
                                <div class="repeater-header">
                                    <h3>Request</h3>
                                    <button id="send-request-btn" class="btn btn-success">Send</button>
                                </div>
                                
                                <div class="repeater-request">
                                    <div class="request-line">
                                        <select id="repeater-method" class="method-select">
                                            <option value="GET">GET</option>
                                            <option value="POST">POST</option>
                                            <option value="PUT">PUT</option>
                                            <option value="DELETE">DELETE</option>
                                            <option value="PATCH">PATCH</option>
                                            <option value="HEAD">HEAD</option>
                                            <option value="OPTIONS">OPTIONS</option>
                                        </select>
                                        <input type="text" id="repeater-url" class="url-input" placeholder="https://example.com/api/endpoint">
                                    </div>
                                    
                                    <div class="repeater-tabs">
                                        <button class="repeater-tab active" data-repeater-tab="headers">Headers</button>
                                        <button class="repeater-tab" data-repeater-tab="body">Body</button>
                                    </div>
                                    
                                    <div class="repeater-tab-content">
                                        <div id="repeater-headers" class="repeater-tab-panel active">
                                            <textarea id="repeater-headers-text" class="repeater-textarea" rows="10" placeholder="Header-Name: value&#10;Content-Type: application/json&#10;Authorization: Bearer token"></textarea>
                                        </div>
                                        <div id="repeater-body" class="repeater-tab-panel">
                                            <textarea id="repeater-body-text" class="repeater-textarea" rows="10" placeholder="Request body content"></textarea>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Response Viewer -->
                            <div class="repeater-section">
                                <div class="repeater-header">
                                    <h3>Response</h3>
                                    <div class="response-status" id="response-status"></div>
                                </div>
                                
                                <div class="repeater-response" id="repeater-response">
                                    <div class="response-empty">
                                        <p>Send a request to see the response here.</p>
                                    </div>
                                </div>
                                
                                <div class="repeater-response-content" id="repeater-response-content" style="display: none;">
                                    <div class="repeater-tabs">
                                        <button class="repeater-tab active" data-response-tab="body">Body</button>
                                        <button class="repeater-tab" data-response-tab="headers">Headers</button>
                                        <button class="repeater-tab" data-response-tab="raw">Raw</button>
                                    </div>
                                    
                                    <div class="repeater-tab-content">
                                        <div id="response-body" class="repeater-tab-panel active">
                                            <pre id="response-body-text" class="response-pre"></pre>
                                        </div>
                                        <div id="response-headers" class="repeater-tab-panel">
                                            <pre id="response-headers-text" class="response-pre"></pre>
                                        </div>
                                        <div id="response-raw" class="repeater-tab-panel">
                                            <pre id="response-raw-text" class="response-pre"></pre>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- History Sidebar -->
                        <div class="repeater-sidebar">
                            <div class="sidebar-header">
                                <h3>History</h3>
                                <button id="clear-repeater-history-btn" class="btn btn-small">Clear</button>
                            </div>
                            <div id="repeater-history-list" class="history-list">
                                <p class="empty-state-small">No requests sent yet.</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <footer>
            <p>Web-Burp v0.1.0 | For authorized testing only</p>
        </footer>
    </div>

    <script>
        // Initialize WebSocket connection
        const socket = io();
        
        // Connection status
        socket.on('connect', () => {
            console.log('WebSocket connected');
        });
        
        socket.on('disconnect', () => {
            console.log('WebSocket disconnected');
        });
        
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                
                // Update active tab button
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update active content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName).classList.add('active');
                
                // Request history when switching to history tab
                if (tabName === 'history') {
                    socket.emit('request_history', { limit: 50 });
                }
                
                // Load intercepted request when switching to intercept tab
                if (tabName === 'intercept' && interceptEnabled && !currentInterceptedRequest) {
                    loadNextInterceptedRequest();
                }
                
                // Load repeater history when switching to repeater tab
                if (tabName === 'repeater') {
                    loadRepeaterHistory();
                }
            });
        });
        
        // Proxy control functions
        const startBtn = document.getElementById('start-proxy-btn');
        const stopBtn = document.getElementById('stop-proxy-btn');
        const clearBtn = document.getElementById('clear-history-btn');
        
        startBtn.addEventListener('click', async () => {
            try {
                const response = await fetch('/api/proxy/start', { method: 'POST' });
                const data = await response.json();
                if (response.ok) {
                    
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Failed to start proxy: ' + error);
            }
        });
        
        stopBtn.addEventListener('click', async () => {
            try {
                const response = await fetch('/api/proxy/stop', { method: 'POST' });
                const data = await response.json();
                if (response.ok) {
                    
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Failed to stop proxy: ' + error);
            }
        });
        
        clearBtn.addEventListener('click', async () => {
            if (confirm('Clear all captured requests?')) {
                try {
                    await fetch('/api/requests/clear', { method: 'POST' });
                } catch (error) {
                    alert('Failed to clear history: ' + error);
                }
            }
        });
        
        // WebSocket event handlers
        socket.on('proxy_status', (data) => {
            console.log('Proxy status update:', data);
            const running = data.running;
            const statusElements = document.querySelectorAll('#proxy-status, #proxy-status-text');
            statusElements.forEach(el => {
                el.textContent = running ? 'Online' : 'Offline';
                el.classList.toggle('online', running);
                el.classList.toggle('offline', !running);
            });
            
            // Update buttons
            startBtn.disabled = running;
            stopBtn.disabled = !running;
            
            // Load exclusions when status updates
            loadExclusions();
        });
        
        socket.on('stats_update', (data) => {
            console.log('Stats update:', data);
            document.getElementById('request-count').textContent = data.total || 0;
        });
        
        socket.on('new_request', (data) => {
            console.log('New request captured:', data);
            // If on history tab, refresh the list
            if (document.getElementById('history').classList.contains('active')) {
                socket.emit('request_history', { limit: 50 });
            }
        });
        
        socket.on('requests_cleared', () => {
            console.log('Requests cleared');
            const requestList = document.getElementById('request-list');
            requestList.innerHTML = '<p class="empty-state">No requests captured yet. Start the proxy and configure your browser.</p>';
        });
        
        socket.on('history_update', (data) => {
            console.log('History update:', data);
            const requestList = document.getElementById('request-list');
            
            if (data.requests.length === 0) {
                requestList.innerHTML = '<p class="empty-state">No requests captured yet. Start the proxy and configure your browser.</p>';
                return;
            }
            
            requestList.innerHTML = data.requests.map(req => `
                <div class="request-item">
                    <div class="request-method ${req.method.toLowerCase()}">${req.method}</div>
                    <div class="request-details">
                        <div class="request-url">${escapeHtml(req.url)}</div>
                        <div class="request-meta">
                            <span class="request-time">${new Date(req.timestamp).toLocaleTimeString()}</span>
                            <span class="request-host">${escapeHtml(req.host)}</span>
                        </div>
                    </div>
                    <button class="btn-send-to-repeater" data-request-id="${req.id}" title="Send to Repeater">
                        ‚Üó
                    </button>
                </div>
            `).join('');
            
            // Add click handlers for "Send to Repeater" buttons
            document.querySelectorAll('.btn-send-to-repeater').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const requestId = parseInt(btn.dataset.requestId);
                    sendToRepeater(requestId);
                });
            });
        });
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Load exclusion list
        async function loadExclusions() {
            try {
                const response = await fetch('/api/proxy/exclusions');
                const data = await response.json();
                
                const exclusionList = document.getElementById('exclusion-list');
                if (data.exclusions.length === 0) {
                    exclusionList.innerHTML = '<li class="empty-exclusions">No exclusions configured</li>';
                    return;
                }
                
                exclusionList.innerHTML = data.exclusions.map(host => `
                    <li class="exclusion-item">
                        <code>${escapeHtml(host)}</code>
                    </li>
                `).join('');
            } catch (error) {
                console.error('Failed to load exclusions:', error);
            }
        }
        
        // Load certificate status
        async function loadCertificateStatus() {
            try {
                const response = await fetch('/api/proxy/certificate');
                const data = await response.json();
                
                const certStatus = document.getElementById('cert-status');
                const certDownload = document.getElementById('cert-download');
                
                if (data.available) {
                    certStatus.innerHTML = '<p class="cert-available">‚úÖ Certificate ready for download</p>';
                    certDownload.style.display = 'block';
                } else {
                    certStatus.innerHTML = `<p class="cert-unavailable">‚è≥ ${data.message}</p>`;
                    certDownload.style.display = 'none';
                }
            } catch (error) {
                console.error('Failed to load certificate status:', error);
            }
        }
        
        // Download certificate button handler
        document.getElementById('download-cert-btn').addEventListener('click', () => {
            window.location.href = '/api/proxy/certificate/download';
        });
        
        // Initial load - request history for current tab
        if (document.getElementById('history').classList.contains('active')) {
            socket.emit('request_history', { limit: 50 });
        }
        
        // Load exclusions and certificate status on page load
        loadExclusions();
        loadCertificateStatus();
        
        // Reload certificate status when proxy status changes
        socket.on('proxy_status', (data) => {
            // ... existing code ...
            // Also reload certificate status since starting proxy generates cert
            setTimeout(loadCertificateStatus, 1000);
        });
        
        // ===== INTERCEPT FUNCTIONALITY =====
        
        let interceptEnabled = false;
        let currentInterceptedRequest = null;
        
        const interceptToggleBtn = document.getElementById('intercept-toggle-btn');
        const interceptStatusIndicator = document.getElementById('intercept-status-indicator');
        const interceptEmpty = document.getElementById('intercept-empty');
        const interceptEditor = document.getElementById('intercept-editor');
        const forwardBtn = document.getElementById('forward-btn');
        const forwardModifiedBtn = document.getElementById('forward-modified-btn');
        const dropBtn = document.getElementById('drop-btn');
        
        // Editor tab switching
        document.querySelectorAll('.editor-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.editorTab;
                
                document.querySelectorAll('.editor-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                document.querySelectorAll('.editor-tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`editor-${tabName}`).classList.add('active');
            });
        });
        
        // Toggle intercept
        interceptToggleBtn.addEventListener('click', async () => {
            try {
                const endpoint = interceptEnabled ? '/api/intercept/disable' : '/api/intercept/enable';
                const response = await fetch(endpoint, { method: 'POST' });
                
                if (response.ok) {
                    interceptEnabled = !interceptEnabled;
                    updateInterceptUI();
                }
            } catch (error) {
                alert('Failed to toggle intercept: ' + error);
            }
        });
        
        function updateInterceptUI() {
            if (interceptEnabled) {
                interceptToggleBtn.textContent = 'Disable Intercept';
                interceptToggleBtn.classList.remove('btn-success');
                interceptToggleBtn.classList.add('btn-danger');
                interceptStatusIndicator.textContent = 'On';
                interceptStatusIndicator.classList.remove('offline');
                interceptStatusIndicator.classList.add('online');
            } else {
                interceptToggleBtn.textContent = 'Enable Intercept';
                interceptToggleBtn.classList.remove('btn-danger');
                interceptToggleBtn.classList.add('btn-success');
                interceptStatusIndicator.textContent = 'Off';
                interceptStatusIndicator.classList.remove('online');
                interceptStatusIndicator.classList.add('offline');
            }
        }
        
        // Display intercepted request in editor
        function displayInterceptedRequest(req) {
            currentInterceptedRequest = req;
            
            // Show editor, hide empty state
            interceptEmpty.style.display = 'none';
            interceptEditor.style.display = 'block';
            
            // Populate form fields
            document.getElementById('current-request-id').textContent = `#${req.id}`;
            document.getElementById('edit-method').value = req.method || '';
            document.getElementById('edit-url').value = req.url || '';
            document.getElementById('edit-path').value = req.path || '';
            document.getElementById('edit-host').value = req.host || '';
            
            // Populate headers
            const headersText = Object.entries(req.headers || {})
                .map(([key, value]) => `${key}: ${value}`)
                .join('\n');
            document.getElementById('edit-headers').value = headersText;
            
            // Populate body
            document.getElementById('edit-body').value = req.content || '';
        }
        
        // Forward request without modifications
        forwardBtn.addEventListener('click', async () => {
            if (!currentInterceptedRequest) return;
            
            try {
                const response = await fetch(`/api/intercept/forward/${currentInterceptedRequest.id}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({})
                });
                
                if (response.ok) {
                    console.log('Request forwarded');
                    loadNextInterceptedRequest();
                }
            } catch (error) {
                alert('Failed to forward request: ' + error);
            }
        });
        
        // Forward request with modifications
        forwardModifiedBtn.addEventListener('click', async () => {
            if (!currentInterceptedRequest) return;
            
            try {
                // Parse headers from textarea
                const headersText = document.getElementById('edit-headers').value;
                const headers = {};
                headersText.split('\n').forEach(line => {
                    const colonIndex = line.indexOf(':');
                    if (colonIndex > 0) {
                        const key = line.substring(0, colonIndex).trim();
                        const value = line.substring(colonIndex + 1).trim();
                        if (key) headers[key] = value;
                    }
                });
                
                const modifications = {
                    method: document.getElementById('edit-method').value,
                    path: document.getElementById('edit-path').value,
                    headers: headers,
                    content: document.getElementById('edit-body').value
                };
                
                const response = await fetch(`/api/intercept/forward/${currentInterceptedRequest.id}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ modifications })
                });
                
                if (response.ok) {
                    console.log('Request forwarded with modifications');
                    loadNextInterceptedRequest();
                }
            } catch (error) {
                alert('Failed to forward modified request: ' + error);
            }
        });
        
        // Drop request
        dropBtn.addEventListener('click', async () => {
            if (!currentInterceptedRequest) return;
            
            if (!confirm('Drop this request? The connection will be terminated.')) {
                return;
            }
            
            try {
                const response = await fetch(`/api/intercept/drop/${currentInterceptedRequest.id}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (response.ok) {
                    console.log('Request dropped');
                    loadNextInterceptedRequest();
                }
            } catch (error) {
                alert('Failed to drop request: ' + error);
            }
        });
        
        // Load next intercepted request
        async function loadNextInterceptedRequest() {
            try {
                const response = await fetch('/api/intercept/next');
                
                if (response.ok) {
                    const req = await response.json();
                    displayInterceptedRequest(req);
                } else if (response.status === 404) {
                    // No more requests in queue (expected behavior)
                    currentInterceptedRequest = null;
                    interceptEditor.style.display = 'none';
                    interceptEmpty.style.display = 'block';
                } else {
                    // Unexpected error
                    console.error('Error loading next request:', response.status, response.statusText);
                }
                
                // Update queue count
                updateQueueCount();
            } catch (error) {
                console.error('Failed to load next intercepted request:', error);
            }
        }
        
        // Update queue count
        async function updateQueueCount() {
            try {
                const response = await fetch('/api/intercept/queue');
                const data = await response.json();
                document.getElementById('queue-count').textContent = data.length || 0;
            } catch (error) {
                console.error('Failed to update queue count:', error);
            }
        }
        
        // WebSocket handlers for intercept
        socket.on('intercept_status', (data) => {
            interceptEnabled = data.enabled;
            updateInterceptUI();
        });
        
        socket.on('intercepted_request', (data) => {
            console.log('New intercepted request:', data);
            
            // If no current request is displayed and we're on intercept tab, show this one
            const onInterceptTab = document.getElementById('intercept').classList.contains('active');
            if (!currentInterceptedRequest && interceptEnabled && onInterceptTab) {
                displayInterceptedRequest(data);
            }
            
            updateQueueCount();
        });
        
        socket.on('request_forwarded', (data) => {
            console.log('Request forwarded:', data);
            updateQueueCount();
        });
        
        socket.on('request_dropped', (data) => {
            console.log('Request dropped:', data);
            updateQueueCount();
        });
        
        // Load intercept status on page load
        async function loadInterceptStatus() {
            try {
                const response = await fetch('/api/intercept/status');
                const data = await response.json();
                interceptEnabled = data.enabled;
                updateInterceptUI();
                updateQueueCount();
                
                // If intercept is enabled and we're on the intercept tab, try to load a request
                const onInterceptTab = document.getElementById('intercept').classList.contains('active');
                if (interceptEnabled && onInterceptTab && !currentInterceptedRequest) {
                    loadNextInterceptedRequest();
                }
            } catch (error) {
                console.error('Failed to load intercept status:', error);
            }
        }
        
        loadInterceptStatus();
        
        // Update dashboard intercept status
        socket.on('intercept_status', (data) => {
            const dashboardStatus = document.querySelector('#dashboard .status-grid .status-card:nth-child(3) .status-indicator');
            if (dashboardStatus) {
                dashboardStatus.textContent = data.enabled ? 'On' : 'Off';
                dashboardStatus.classList.toggle('online', data.enabled);
                dashboardStatus.classList.toggle('offline', !data.enabled);
            }
        });
        
        // ===== REPEATER FUNCTIONALITY =====
        
        const sendRequestBtn = document.getElementById('send-request-btn');
        const clearRepeaterHistoryBtn = document.getElementById('clear-repeater-history-btn');
        
        // Repeater tab switching (request tabs)
        document.querySelectorAll('.repeater-tab[data-repeater-tab]').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.repeaterTab;
                
                document.querySelectorAll('.repeater-tab[data-repeater-tab]').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                document.querySelectorAll('#repeater-headers, #repeater-body').forEach(panel => {
                    panel.classList.remove('active');
                });
                document.getElementById(`repeater-${tabName}`).classList.add('active');
            });
        });
        
        // Response tab switching
        document.querySelectorAll('.repeater-tab[data-response-tab]').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.responseTab;
                
                document.querySelectorAll('.repeater-tab[data-response-tab]').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                document.querySelectorAll('#response-body, #response-headers, #response-raw').forEach(panel => {
                    panel.classList.remove('active');
                });
                document.getElementById(`response-${tabName}`).classList.add('active');
            });
        });
        
        // Send request
        sendRequestBtn.addEventListener('click', async () => {
            const method = document.getElementById('repeater-method').value;
            const url = document.getElementById('repeater-url').value.trim();
            const headersText = document.getElementById('repeater-headers-text').value;
            const body = document.getElementById('repeater-body-text').value;
            
            if (!url) {
                alert('Please enter a URL');
                return;
            }
            
            // Parse headers
            const headers = {};
            headersText.split('\n').forEach(line => {
                const colonIndex = line.indexOf(':');
                if (colonIndex > 0) {
                    const key = line.substring(0, colonIndex).trim();
                    const value = line.substring(colonIndex + 1).trim();
                    if (key) headers[key] = value;
                }
            });
            
            // Disable button and show loading
            sendRequestBtn.disabled = true;
            sendRequestBtn.textContent = 'Sending...';
            
            try {
                const response = await fetch('/api/repeater/send', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        method: method,
                        url: url,
                        headers: headers,
                        body: body
                    })
                });
                
                const data = await response.json();
                
                if (response.ok && data.response) {
                    displayResponse(data.response);
                    loadRepeaterHistory();
                } else if (data.error) {
                    displayError(data.error);
                }
                
            } catch (error) {
                displayError('Failed to send request: ' + error);
            } finally {
                sendRequestBtn.disabled = false;
                sendRequestBtn.textContent = 'Send';
            }
        });
        
        // Display response
        function displayResponse(response) {
            const responseEmpty = document.querySelector('.response-empty');
            const responseContent = document.getElementById('repeater-response-content');
            const statusElement = document.getElementById('response-status');
            
            // Hide empty, show content
            if (responseEmpty) responseEmpty.style.display = 'none';
            responseContent.style.display = 'block';
            
            // Display status
            const statusClass = response.status_code < 300 ? 'status-success' : 
                               response.status_code < 400 ? 'status-redirect' :
                               response.status_code < 500 ? 'status-client-error' : 'status-server-error';
            
            statusElement.innerHTML = `
                <span class="${statusClass}">${response.status_code} ${escapeHtml(response.status_text)}</span>
                <span class="response-time">${response.elapsed_ms}ms</span>
            `;
            
            // Display body
            const bodyText = response.body || '';
            document.getElementById('response-body-text').textContent = formatResponseBody(bodyText);
            
            // Display headers
            const headersText = Object.entries(response.headers || {})
                .map(([key, value]) => `${key}: ${value}`)
                .join('\n');
            document.getElementById('response-headers-text').textContent = headersText;
            
            // Display raw
            const rawText = `HTTP/1.1 ${response.status_code} ${response.status_text}\n${headersText}\n\n${bodyText}`;
            document.getElementById('response-raw-text').textContent = rawText;
        }
        
        // Display error
        function displayError(errorMessage) {
            const responseEmpty = document.querySelector('.response-empty');
            const responseContent = document.getElementById('repeater-response-content');
            const statusElement = document.getElementById('response-status');
            
            if (responseEmpty) responseEmpty.style.display = 'none';
            responseContent.style.display = 'block';
            
            statusElement.innerHTML = '<span class="status-error">Error</span>';
            document.getElementById('response-body-text').textContent = errorMessage;
            document.getElementById('response-headers-text').textContent = '';
            document.getElementById('response-raw-text').textContent = errorMessage;
        }
        
        // Format response body (try to pretty-print JSON)
        function formatResponseBody(body) {
            try {
                const json = JSON.parse(body);
                return JSON.stringify(json, null, 2);
            } catch {
                return body;
            }
        }
        
        // Load repeater history
        async function loadRepeaterHistory() {
            try {
                const response = await fetch('/api/repeater/history?limit=20');
                const data = await response.json();
                
                const historyList = document.getElementById('repeater-history-list');
                
                if (data.history.length === 0) {
                    historyList.innerHTML = '<p class="empty-state-small">No requests sent yet.</p>';
                    return;
                }
                
                historyList.innerHTML = data.history.map(entry => {
                    const req = entry.request;
                    const res = entry.response;
                    const statusClass = res && res.status_code ? 
                        (res.status_code < 300 ? 'success' : res.status_code < 400 ? 'redirect' : 'error') : 'error';
                    
                    return `
                        <div class="history-item" data-entry-id="${entry.id}">
                            <div class="history-method ${req.method.toLowerCase()}">${req.method}</div>
                            <div class="history-details">
                                <div class="history-url">${escapeHtml(getUrlPath(req.url))}</div>
                                <div class="history-meta">
                                    <span class="history-status status-${statusClass}">
                                        ${res && res.status_code ? res.status_code : 'Error'}
                                    </span>
                                    <span class="history-time">${new Date(entry.timestamp).toLocaleTimeString()}</span>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Add click handlers to history items
                document.querySelectorAll('.history-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const entryId = parseInt(item.dataset.entryId);
                        loadRepeaterEntry(entryId);
                    });
                });
                
            } catch (error) {
                console.error('Failed to load repeater history:', error);
            }
        }
        
        // Load specific repeater entry
        async function loadRepeaterEntry(entryId) {
            try {
                const response = await fetch(`/api/repeater/history/${entryId}`);
                const entry = await response.json();
                
                if (entry.request) {
                    const req = entry.request;
                    document.getElementById('repeater-method').value = req.method;
                    document.getElementById('repeater-url').value = req.url;
                    
                    const headersText = Object.entries(req.headers || {})
                        .map(([key, value]) => `${key}: ${value}`)
                        .join('\n');
                    document.getElementById('repeater-headers-text').value = headersText;
                    document.getElementById('repeater-body-text').value = req.body || '';
                }
                
                if (entry.response) {
                    displayResponse(entry.response);
                }
                
            } catch (error) {
                console.error('Failed to load repeater entry:', error);
            }
        }
        
        // Get URL path from full URL
        function getUrlPath(url) {
            try {
                const urlObj = new URL(url);
                return urlObj.pathname + urlObj.search;
            } catch {
                return url;
            }
        }
        
        // Clear repeater history
        clearRepeaterHistoryBtn.addEventListener('click', async () => {
            if (!confirm('Clear all repeater history?')) {
                return;
            }
            
            try {
                await fetch('/api/repeater/history/clear', { method: 'POST' });
                loadRepeaterHistory();
            } catch (error) {
                alert('Failed to clear history: ' + error);
            }
        });
        
        // WebSocket handlers for repeater
        socket.on('repeater_response', (data) => {
            console.log('Repeater response received:', data);
            loadRepeaterHistory();
        });
        
        socket.on('repeater_history_cleared', () => {
            console.log('Repeater history cleared');
            loadRepeaterHistory();
        });
        
        // Send request to repeater
        async function sendToRepeater(requestId) {
            try {
                const response = await fetch(`/api/requests/${requestId}`);
                const req = await response.json();
                
                if (req) {
                    // Populate repeater with request data
                    document.getElementById('repeater-method').value = req.method || 'GET';
                    document.getElementById('repeater-url').value = req.url || '';
                    
                    // Format headers
                    const headersText = Object.entries(req.headers || {})
                        .map(([key, value]) => `${key}: ${value}`)
                        .join('\n');
                    document.getElementById('repeater-headers-text').value = headersText;
                    
                    // Set body
                    document.getElementById('repeater-body-text').value = req.content || '';
                    
                    // Switch to repeater tab
                    document.querySelector('[data-tab="repeater"]').click();
                    
                    console.log('Request sent to repeater:', req);
                } else {
                    alert('Failed to load request');
                }
            } catch (error) {
                console.error('Failed to send request to repeater:', error);
                alert('Failed to send to repeater: ' + error);
            }
        }
    </script>
</body>
</html>
